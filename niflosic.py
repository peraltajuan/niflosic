from pyscf.lib import logger
import scipy
import torch
from scipy.linalg import qr, inv, pinv, eigh
from torch.autograd import Function
import numpy as np
from  pyscf.scf import  hf, uhf, chkfile
from  pyscf.dft import rks, uks
from  pyscf import  dft, lib,  __config__
import pyscf 


def printM(a):
    for row in a:
        for col in row:
            print("{:9.6f}".format(col), end=" ")
        print("")

def printL(a):
    for i,r in enumerate(a):
          print(f"{r:9.6f}", end=" ")
          if ((i+1) % 8) == 0: print("")
    print("")

def printLi(s,a):
    print(s)
    for i,r in enumerate(a):
          print(f"{r:3d}", end=" ")
          if ((i+1) % 20) == 0: print("")
    print("")



from pyscf.dft.gen_grid import BLKSIZE, NBINS, CUTOFF, ALIGNMENT_UNIT, make_mask


from pyscf.dft.numint import _scale_ao_sparse
from pyscf.dft.numint import _format_uks_dm
from pyscf.dft.numint import _dot_ao_ao_sparse
from pyscf.dft.numint import _tau_dot_sparse


def nr_uks(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
           max_memory=2000, verbose=None):
    '''Calculate UKS XC functional and potential matrix on given meshgrids
    for a set of density matrices

    Args:
        mol : an instance of :class:`Mole`

        grids : an instance of :class:`Grids`
            grids.coords and grids.weights are needed for coordinates and weights of meshgrids.
        xc_code : str
            XC functional description.
            See :func:`parse_xc` of pyscf/dft/libxc.py for more details.
        dms : a list of 2D arrays
            A list of density matrices, stored as (alpha,alpha,...,beta,beta,...)

    Kwargs:
        hermi : int
            Input density matrices symmetric or not. It also indicates whether
            the potential matrices in return are symmetric or not.
        max_memory : int or float
            The maximum size of cache to use (in MB).

    Returns:
        nelec, excsum, vmat.
        nelec is the number of (alpha,beta) electrons generated by numerical integration.
        excsum is the XC functional value.
        vmat is the XC potential matrix for (alpha,beta) spin.

    Examples:

    >>> from pyscf import gto, dft
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> grids = dft.gen_grid.Grids(mol)
    >>> grids.coords = np.random.random((100,3))  # 100 random points
    >>> grids.weights = np.random.random(100)
    >>> nao = mol.nao_nr()
    >>> dm = numpy.random.random((2,nao,nao))
    >>> ni = dft.numint.NumInt()
    >>> nelec, exc, vxc = ni.nr_uks(mol, grids, 'lda,vwn', dm)
    '''
    xctype = ni._xc_type(xc_code)
    ao_loc = mol.ao_loc_nr()
    cutoff = grids.cutoff * 1e2
    nbins = NBINS * 2 - int(NBINS * np.log(cutoff) / np.log(grids.cutoff))

    dma, dmb = _format_uks_dm(dms)
    nao = dma.shape[-1]
    make_rhoa, nset = ni._gen_rho_evaluator(mol, dma, hermi, False, grids)[:2]
#    make_rhob       =     ni._gen_rho_evaluator(mol, dmb, hermi, False, grids)[0]

    nelec = np.zeros((2,nset))
    excsum = np.zeros(nset)
    vmat = np.zeros((2,nset,nao,nao))

    def block_loop(ao_deriv):
        for ao, mask, weight, coords \
                in ni.block_loop(mol, grids, nao, ao_deriv, max_memory=max_memory):
            for i in range(nset):
                rho_a = make_rhoa(i, ao, mask, xctype)
                rho_b = 0.*rho_a # make_rhob(i, ao, mask, xctype)
                exc, vxc = ni.eval_xc_eff(xc_code, (rho_a, rho_b)  , deriv=1, xctype=xctype)[:2]
                if xctype == 'LDA':
                    den_a = rho_a * weight
#                    den_b = rho_b * weight
                else:
                    den_a = rho_a[0] * weight
#                    den_b = rho_b[0] * weight
                nelec[0,i] += den_a.sum()
#                nelec[1,i] += den_b.sum()
                excsum[i] += np.dot(den_a, exc)
#                excsum[i] += np.dot(den_b, exc)
                wv = weight * vxc
                yield i, ao, mask, wv

    pair_mask = mol.get_overlap_cond() < -np.log(ni.cutoff)
    aow = None
    if xctype == 'LDA':
        ao_deriv = 0
        for i, ao, mask, wv in block_loop(ao_deriv):
            _dot_ao_ao_sparse(ao, ao, wv[0,0], nbins, mask, pair_mask, ao_loc,
                              hermi, vmat[0,i])
#            _dot_ao_ao_sparse(ao, ao, wv[1,0], nbins, mask, pair_mask, ao_loc,
#                              hermi, vmat[1,i])

    elif xctype == 'GGA':
        ao_deriv = 1
        for i, ao, mask, wv in block_loop(ao_deriv):
            wv[:,0] *= .5
            wva, wvb = wv
            aow = _scale_ao_sparse(ao, wva, mask, ao_loc, out=aow)
            _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
                              hermi=0, out=vmat[0,i])
#            aow = _scale_ao_sparse(ao, wvb, mask, ao_loc, out=aow)
#            _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
#                              hermi=0, out=vmat[1,i])
        vmat = lib.hermi_sum(vmat.reshape(-1,nao,nao), axes=(0,2,1)).reshape(2,nset,nao,nao)

    elif xctype == 'MGGA':
        if (any(x in xc_code.upper() for x in ('CC06', 'CS', 'BR89', 'MK00'))):
            raise NotImplementedError('laplacian in meta-GGA method')
#        assert not MGGA_DENSITY_LAPL
        ao_deriv = 1
        v1 = np.zeros_like(vmat)
        for i, ao, mask, wv in block_loop(ao_deriv):
            wv[:,0] *= .5
            wv[:,4] *= .5
            wva, wvb = wv
            aow = _scale_ao_sparse(ao[:4], wva[:4], mask, ao_loc, out=aow)
            _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
                              hermi=0, out=vmat[0,i])
            _tau_dot_sparse(ao, ao, wva[4], nbins, mask, pair_mask, ao_loc, out=v1[0,i])
#            aow = _scale_ao_sparse(ao[:4], wvb[:4], mask, ao_loc, out=aow)
#            _dot_ao_ao_sparse(ao[0], aow, None, nbins, mask, pair_mask, ao_loc,
#                              hermi=0, out=vmat[1,i])
#            _tau_dot_sparse(ao, ao, wvb[4], nbins, mask, pair_mask, ao_loc, out=v1[1,i])
        vmat = lib.hermi_sum(vmat.reshape(-1,nao,nao), axes=(0,2,1)).reshape(2,nset,nao,nao)
        vmat += v1
    elif xctype == 'HF':
        pass
    else:
        raise NotImplementedError(f'numint.nr_uks for functional {xc_code}')

    if isinstance(dma, np.ndarray) and dma.ndim == 2:
        vmat = vmat[:,0]
        nelec = nelec.reshape(2)
        excsum = excsum[0]

    dtype = np.result_type(dma, dmb)
    if vmat.dtype != dtype:
        vmat = np.asarray(vmat, dtype=dtype)
    return nelec, excsum, vmat








def hxcsic(mf,mol):
    P = mf.make_rdm1()
    if P.ndim == 2:  
      is_r = True
      P_loc =  mf.ploc
    else: 
      is_r = False
      P_loc_a =  mf.ploca
      P_loc_b =  mf.plocb

    grid = pyscf.dft.gen_grid.Grids(mol)
#    grid.atom_grid =  (200, 350)
    grid.build() 
    coords = grid.coords
    weights = grid.weights

    xctype = dft.xcfun.xc_type(mf.xc)

    if xctype == 'LDA': deriv = 0 
    else: deriv = 1 
    ao_value = dft.numint.eval_ao(mol, coords, deriv=deriv)

    S = mol.intor('int1e_ovlp')

    exchange = mf.xc.split(',')[0]
    correlation = mf.xc.split(',')[1]

    if not is_r: 
         P_loc = np.concatenate([P_loc_a, P_loc_b])
    else:
         P_loc = P_loc*2.0


    HXC = 0.0 
    J = mf.get_j(mol,dm=P_loc)  # can we do all at once?
    if is_r:  J *=.25
    for i, dm in enumerate(P_loc):
        rho = 0.5*dft.numint.eval_rho(mol, ao_value, dm, xctype=xctype)
        rhoz = np.zeros_like(rho)
        if xctype == 'LDA': n=rho
        else: n=rho[0]
        e_x  = dft.xcfun.eval_xc(exchange+','   , (rho, rhoz), spin=1,deriv=0)[0]
        e_c  = dft.xcfun.eval_xc(','+correlation, (rho, rhoz), spin=1,deriv=0)[0]
        Ex = sum(e_x * weights *n )
        Ec = sum(e_c * weights *n )
        rhoint = sum(n * weights)
        Har= 0.5*np.trace(dm @ J[i])
        HXC += -Ex -Ec -Har
        print('e-count, Hartree, XC = ',rhoint,-Har, -Ex-Ec)
    if is_r:  HXC *= 2.0 

    return HXC 






def lowdin_pop(mol, dm, S ):
    '''Lowdin population analysis

    Prints Lowdin Population for charge and spin    

    '''
    print('')
    print(' Lodwin Population')
    if dm.ndim == 2: is_r = True
    else: is_r = False

    s12 = scipy.linalg.sqrtm(S).real
    if not is_r:
       print(' Center         charge       spin ')
       SPSa = s12 @ dm[0] @s12
       SPSb = s12 @ dm[1] @s12
       popa= np.diag(SPSa)
       popb= np.diag(SPSb)
       chga = np.zeros(mol.natm)
       chgb = np.zeros(mol.natm)
       for i, s in enumerate(mol.ao_labels(fmt=None)):
           chga[s[0]] += popa[i]
           chgb[s[0]] += popb[i]
       for ia in range(mol.natm):
           symb = mol.atom_symbol(ia)
           achg = mol.atom_charge(ia)
           CH = -chga[ia] -chgb[ia] + achg 
           SP = chga[ia] - chgb[ia]
           print(f' {ia:3d}{symb:s}       {CH:10.5f} {SP:10.5f} ')
    else:
       print(' Center         charge    ')
       SPS = s12 @ dm @s12
       pop= np.diag(SPS)
       chg = np.zeros(mol.natm)
       for i, s in enumerate(mol.ao_labels(fmt=None)):
           chg[s[0]] += pop[i]
       for ia in range(mol.natm):
           symb = mol.atom_symbol(ia)
           achg = mol.atom_charge(ia)
           CH = -chg[ia] + achg 
           print(f' {ia:3d}{symb:s}       {CH:10.5f} ')




class MatrixSQRT(Function):
    """Square root of a positive definite matrix to use with torch autograd.
    NOTE: matrix square root will break if there are zero eigenvalues
          This version uses the analytical expression instead of the Sylvester solver
    """
    @staticmethod
    def forward(ctx, input):
        m = input.detach().cpu().numpy().astype(np.float64)
        sqrtma = torch.from_numpy(scipy.linalg.sqrtm(m).real).to(input)
        ctx.save_for_backward(sqrtma)
        return sqrtma

    @staticmethod
    def backward(ctx, grad_output):
        grad_input = None
        if ctx.needs_input_grad[0]:
            sqrtma, = ctx.saved_tensors
            sqrtma = sqrtma.data.cpu().numpy().astype(np.float64)
            gm = grad_output.data.cpu().numpy().astype(np.float64)

#           https://doi.org/10.1063/1.3624397 Cheng and Gauss, J. Chem. Phys. 135, 084114 (2011)
            Z, Y = eigh(sqrtma)
            YTAY =  Y.T @ gm @ Y
            Zdd = np.add.outer(Z, Z) 
            YTBY = YTAY/Zdd
            grad_sqrtm = Y @ YTBY @ Y.T
            grad_input = torch.from_numpy(grad_sqrtm).to(grad_output)
        return grad_input


sqrtm = MatrixSQRT.apply


def dump_scf_summary(mf, verbose=logger.DEBUG):
    '''
    **** This is an in-house modified version to work with SIC ****
    '''
    if not mf.scf_summary:
        return

    log = logger.new_logger(mf, verbose)
    summary = mf.scf_summary
    def write(fmt, key):
        if key in summary:
            log.info(fmt, summary[key])
    log.info('**** SCF Summaries ****')
    log.info('Total Energy =                    %24.15f', mf.e_tot)
    write('Nuclear Repulsion Energy =        %24.15f', 'nuc')
    write('One-electron Energy =             %24.15f', 'e1')
    write('Two-electron Energy =             %24.15f', 'e2')
    write('Two-electron Coulomb Energy =     %24.15f', 'coul')
    write('DFT Exchange-Correlation Energy = %24.15f', 'exc')
    write('Total DFT Energy                = %24.15f', 'dft')
    write('SIC  Energy                     = %24.15f', 'esic')
    write('Empirical Dispersion Energy =     %24.15f', 'dispersion')
    write('PCM Polarization Energy =         %24.15f', 'epcm')
    write('EFP Energy =                      %24.15f', 'efp')
    if getattr(mf, 'entropy', None):
        log.info('(Electronic) Entropy              %24.15f', mf.entropy)
        log.info('(Electronic) Zero Point Energy    %24.15f', mf.e_zero)
        log.info('Free Energy =                     %24.15f', mf.e_free)


# JEP we need a newsic_fod function that generates FLO for a given set of FODs.  
# Or we can add a "method" here that is just read the FODs from the arguments or from mol?



def newsic_fod(mol,mf,PM,FOD,orbs='flo'):
    '''
    orbs:   scdm-g
            flo
    This funcion uses FOD to build local orbitals and densities 
    and stores the local orbital coefficients and density matrices attached to the mean field object mf. 
    mf.orbs    mf.orbs_a    mf.orbs_b     : Local Orbital coefficients (orthogonal)
    mf.ploc    mf.ploc_a    mf.ploc_b     : Local DM 
    mf.eigenv  mf.eigenv_a  mf.eigenv_b   : Eigenvalues of the non-orth local orbitals overlap matrix
    mf.cond    mf.cond_a    mf.cond_b     : Condition number of the same matrix
    '''
   
    S = mol.intor('int1e_ovlp')
    if PM.ndim == 2: 
          is_r = True
          P = 0.5*PM
          fod = FOD.reshape((-1,3)).copy()
    else: 
          is_r = False
          Pa = PM[0]
          Pb = PM[1]
          Na, Nb = mol.nelec
          fod = FOD.reshape((-1,3)).copy()
          fod_a = fod[:Na]
          fod_b = fod[Na:]
          assert Na+Nb == len(fod), 'Len of FODs is wrong'

    ni = rks.numint


# decide RKS or UKS
    if is_r:
        ao = mol.eval_gto('GTOval', fod)
        rho = dft.numint.eval_rho(mol, ao, P, xctype ='LDA')
        sqrt_rho = np.sqrt(rho)   
    else:   
        ao_a = mol.eval_gto('GTOval', fod_a)
        ao_b = mol.eval_gto('GTOval', fod_b)
        
        rho_a  = ni.eval_rho(mol, ao_a, Pa ,xctype ='LDA')
        rho_b  = ni.eval_rho(mol, ao_b, Pb ,xctype ='LDA')

        sqrt_rho_a = np.sqrt(rho_a)
        sqrt_rho_b = np.sqrt(rho_b)



       
    if is_r:
        mf.fod = fod
        mf.ao = ao
    else:
        mf.fod_a = fod_a
        mf.fod_b = fod_b
        mf.ao_a = ao_a
        mf.ao_b = ao_b



    
    if is_r:
        if orbs=='scdm-g' or orbs=='flo' : 
           if orbs=='scdm-g' : Y =  mf.ao.T 
           if orbs=='flo' : Y =  mf.ao.T / sqrt_rho
           P = PM*.5
           G =   P @ Y
           O = Y.T @ P @ Y
           O12 = scipy.linalg.sqrtm(O).real
           Om12= scipy.linalg.pinv(O12).real 
           X = G @ Om12 
           P_loc = np.einsum('ia,ja->aji',X,X)
           SPloc = np.sum(P_loc, axis=0) 
           if 'testfd' not in dir(mf):  
               print('*** deviation sum_Pi from total P:', np.linalg.norm(SPloc-P) )
               assert np.linalg.norm(SPloc-P) <= 1E-8, 'Localized Densities'
           mf.orbs = X.T
           mf.ploc = P_loc
           mf.eigenv = np.linalg.eigvalsh(O)
           mf.cond   = np.linalg.cond(O)
        else: raise ValueError('Wrong orbital construction (use scdm-g,flo)')



    else:
        if orbs=='scdm-g' or orbs=='flo' : 
           if orbs=='scdm-g' : 
               Y_a =  mf.ao_a.T 
               Y_b =  mf.ao_b.T 
           if orbs=='flo' : 
               Y_a =  mf.ao_a.T / sqrt_rho_a
               Y_b =  mf.ao_b.T / sqrt_rho_b
           
         
#           print(D_a,D_b)

           P_a = PM[0]
           P_b = PM[1]
           G_a =   P_a @ Y_a
           G_b =   P_b @ Y_b
           O_a = Y_a.T @ P_a @ Y_a
           O_b = Y_b.T @ P_b @ Y_b
           O12_a = scipy.linalg.sqrtm(O_a).real
           O12_b = scipy.linalg.sqrtm(O_b).real
           Om12_a= scipy.linalg.pinv(O12_a).real 
           Om12_b= scipy.linalg.pinv(O12_b).real 
           X_a = G_a @ Om12_a 
           X_b = G_b @ Om12_b 
           P_loc_a = np.einsum('ia,ja->aji',X_a,X_a)
           P_loc_b = np.einsum('ia,ja->aji',X_b,X_b)
           SPloc_a = np.sum(P_loc_a, axis=0) 
           SPloc_b = np.sum(P_loc_b, axis=0) 
           if 'testfd' not in dir(mf): assert np.linalg.norm(SPloc_a-P_a) <= 1E-7, 'Localized Densities alpha'
           if 'testfd' not in dir(mf): assert np.linalg.norm(SPloc_b-P_b) <= 1E-7, 'Localized Densities beta '
           mf.orbs_a = X_a.T
           mf.orbs_b = X_b.T
           mf.ploc_a = P_loc_a
           mf.ploc_b = P_loc_b

        else: raise ValueError('Wrong orbital construction (use scdm-g,flo)')
 






def newsic_g(mol,mf,PM,method='scdm-g',orbs='flo'):
    '''
    Initiallize FODs using QR grid decomposition
    method: scdm-g (Fuemmeler et al. J. Chem. Theory Comput. 2023 19 (23), 8572-8586 DOI: 10.1021/acs.jctc.1c00801) 
            elf    
            lol   
            grid (only for RHF)  
    orbs:   scdm-g
            flo
    This funcion returns the FODs and stores the local orbital coefficients and density matrices attached to the mean field object mf. 
    mf.orbs    mf.orbs_a    mf.orbs_b     : Local Orbital coefficients (orthogonal)
    mf.ploc    mf.ploc_a    mf.ploc_b     : Local DM 
    mf.eigenv  mf.eigenv_a  mf.eigenv_b   : Eigenvalues of the non-orth local orbitals overlap matrix
    mf.cond    mf.cond_a    mf.cond_b     : Condition number of the same matrix
    '''
   
    S = mol.intor('int1e_ovlp')


#   check https://pyscf.org/_modules/pyscf/dft/LebedevGrid.html#MakeAngularGrid
    grid = pyscf.dft.gen_grid.Grids(mol)
    grid.atom_grid = (40, 110)#  (200,350) #(40, 110)  
    grid.build()
    coords = grid.coords
    weights = grid.weights

    ao = mol.eval_gto('GTOval', coords)
    ni =  dft.numint

# decide RKS or UKS
    if PM.ndim == 2: is_r = True
    else: is_r = False
    if is_r:
        P = 0.5*PM
        orbitals = mf.mo_coeff
        mo = ao @ orbitals
        moe = mf.mo_energy 
        nocc =    mol.nelec[0] 
        energies = mf.mo_energy
        fo = mo[:,:nocc]
        gao = mol.eval_gto('GTOval_ip', coords)
        aogao = np.array((ao,gao[0],gao[1],gao[2]))
        rho,gx,gy,gz,tau =  ni.eval_rho(mol, aogao, P ,xctype ='MGGA',with_lapl=False)
        sqrt_rho = np.sqrt(rho)   
        grad2 = gx**2+gy**2+gz**2
        vwke  = grad2/8.0/rho
        Dh     = 3.0/10.0*(3.*np.pi**2)**(2./3.)*rho**(5./3.)
        D = tau - vwke
        elf = 1.0/( 1.0 + (D/Dh)**2 )
        elf = np.nan_to_num(elf,nan=0.0, posinf=0.0, neginf=0.0)
        lol = 1./(1.+2.*tau/Dh)
        lol = np.nan_to_num(lol,nan=0.0, posinf=0.0, neginf=0.0)

        if method=='scdm-g': pass
        elif method=='flo': 
           for i in range(nocc): 
                 fo[:,i] = fo[:,i]/sqrt_rho
        elif method=='elf': 
           for i in range(nocc): 
                 maxf = np.sqrt(max(fo[:,i]**2 /rho ))
                 fo[:,i] =fo[:,i]/sqrt_rho /maxf * elf
        elif method=='flo': 
           for i in range(nocc): 
                 fo[:,i] = fo[:,i]/sqrt_rho
        elif method=='lol': 
           for i in range(nocc): 
                 maxf = np.sqrt(max(fo[:,i]**2))
                 fo[:,i] =  fo[:,i]/maxf*lol
        elif method=='grid': 
           print_xyz(mol,coords,"GRID."+method+".fods")
           raise ValueError('Generating grid xyz for visualization')
        else: raise ValueError('Wrong Method (use scdm-g,elf,lol,flo)')

    else:   
        P = PM
        mo_a = ao @ mf.mo_coeff[0]
        mo_b = ao @ mf.mo_coeff[1]
        nocc_a = mol.nelec[0]
        nocc_b = mol.nelec[1]
        fo_a = mo_a[:,:nocc_a] 
        fo_b = mo_b[:,:nocc_b] 
        orbitals_a = mf.mo_coeff[0]
        orbitals_b = mf.mo_coeff[1]
        gao = mol.eval_gto('GTOval_ip', coords)
        aogao = np.array((ao,gao[0],gao[1],gao[2]))
        rho_a,gx_a,gy_a,gz_a,tau_a =  ni.eval_rho(mol, aogao, P[0] ,xctype ='MGGA',with_lapl=False)
        rho_b,gx_b,gy_b,gz_b,tau_b =  ni.eval_rho(mol, aogao, P[1] ,xctype ='MGGA',with_lapl=False)
        sqrt_rho_a = np.sqrt(rho_a)
        sqrt_rho_b = np.sqrt(rho_b)
        grad2_a = gx_a**2+gy_a**2+gz_a**2
        grad2_b = gx_b**2+gy_b**2+gz_b**2
        vwke_a  = grad2_a/8.0/rho_a
        vwke_b  = grad2_b/8.0/rho_b
        Dh_a     = 3.0/10.0*(3*np.pi**2)**(2./3.)*rho_a**(5./3.)
        Dh_b     = 3.0/10.0*(3*np.pi**2)**(2./3.)*rho_b**(5./3.)
        D_a = tau_a - vwke_a
        D_b = tau_b - vwke_b
        elf_a = 1.0/( 1.0 + (D_a/Dh_a)**2 )
        elf_b = 1.0/( 1.0 + (D_b/Dh_b)**2 )
        elf_a = np.nan_to_num(elf_a,nan=0.0, posinf=0.0, neginf=0.0)
        elf_b = np.nan_to_num(elf_b,nan=0.0, posinf=0.0, neginf=0.0)
        lol_a = 1./(1.+2.*tau_a/Dh_a)
        lol_b = 1./(1.+2.*tau_b/Dh_b)
        lol_a = np.nan_to_num(lol_a,nan=0.0, posinf=0.0, neginf=0.0)
        lol_b = np.nan_to_num(lol_b,nan=0.0, posinf=0.0, neginf=0.0)



        if method=='scdm-g': pass
        elif method=='flo': 
           for i in range(nocc): 
                 fo_a[:,i] = fo_a[:,i]/sqrt_rho_a
                 fo_b[:,i] = fo_b[:,i]/sqrt_rho_b
        elif method=='elf': 
           for i in range(nocc_a): 
                maxf = np.sqrt(max(fo_a[:,i]**2 /rho_a ))
                fo_a[:,i] =fo_a[:,i]/sqrt_rho_a /maxf * elf_a
           for i in range(nocc_b): 
                maxf = np.sqrt(max(fo_b[:,i]**2 /rho_b ))
                fo_b[:,i] =fo_b[:,i]/sqrt_rho_b /maxf * elf_b
        elif method=='lol': 
           for i in range(nocc_a): 
                maxf = np.sqrt(max(fo_a[:,i]**2))
                fo_a[:,i] = fo_a[:,i]/maxf*lol_a
           for i in range(nocc_b): 
                maxf = np.sqrt(max(fo_b[:,i]**2))
                fo_b[:,i] = fo_b[:,i]/maxf*lol_b
        else: raise ValueError('Wrong Method (use scdm-g,elf,lol,flo)')

    if mf.do_piv == False and 'testfd' not in dir(mf):
      print('*** using previous pivoting vectors (do_piv=False) ***')
       
    if mf.do_piv == True:  
     print('*** evaluating pivoting vectors ***' )
     # restricted case
     if is_r:
        Q,  R, piv = scipy.linalg.qr(fo.T , pivoting=True);
        PIV = piv[0:nocc]
        mf.piv  = PIV 
        DM = scipy.spatial.distance_matrix(coords[PIV],coords[PIV])
        D = np.linalg.norm(DM)
        print('*** D is: ',D)
        rank = np.sum(np.abs(np.diag(R)) > 1e-10)
        print('Rank of matrix = ', rank)



#        Delta_E = 1.0
        if 'e_new' in dir(mf) and 'e_old' in dir(mf): Delta_E = mf.e_new - mf.e_old
        print('Delta_E = ' , Delta_E)
        Delta_D = 9.e9

        if (Delta_D>=1.e8): # and (Delta_E > 0.0):
            mf.piv  = PIV 
            mf.fod = coords[PIV]
            mf.ao = ao[PIV]
            mf.d = D
            print('*** new pivoting vectors will be used ***')
            printM(coords[PIV])
            mf.do_piv = False # remove this!
        else:
            if 'testfd' not in dir(mf): print('*** using previous pivoting vectors ***')
            mf.do_piv = False

     #  unrestricted case
     else:
        Q,  R, piv = scipy.linalg.qr(fo_a.T , pivoting=True);
        PIV_a = piv[0:nocc_a]
        Q,  R, piv = scipy.linalg.qr(fo_b.T , pivoting=True);
        PIV_b = piv[0:nocc_b]
        mf.fod_a = coords[PIV_a]
        mf.fod_b = coords[PIV_b]
        DM_a = scipy.spatial.distance_matrix(coords[PIV_a],coords[PIV_a])
        DM_b = scipy.spatial.distance_matrix(coords[PIV_b],coords[PIV_b])
        D_a = np.linalg.norm(DM_a)
        D_b = np.linalg.norm(DM_b)
         
        Delta_D = 9e9
        try:
           Delta_D = np.sqrt( (mf.d_a - D_a)**2 + (mf.d_b - D_b)**2 )
           print('*** Delta_D is: ',Delta_D)
           if 'testfd' not in dir(ks)  and   Delta_D >= 1.E-8:
              mf.piv_a = PIV_a
              mf.piv_b = PIV_b
              mf.fod_a = coords[PIV_a]
              mf.fod_b = coords[PIV_b]
              mf.ao_a = ao[PIV_a]
              mf.ao_b = ao[PIV_b]
              mf.d_a = D_a
              mf.d_b = D_b
        except:
           mf.piv_a = PIV_a
           mf.piv_b = PIV_b
           mf.fod_a = coords[PIV_a]
           mf.fod_b = coords[PIV_b]
           mf.ao_a = ao[PIV_a]
           mf.ao_b = ao[PIV_b]
           mf.d_a = D_a
           mf.d_b = D_b
        mf.do_piv = False



    
    if is_r:
        if orbs=='scdm-g' or orbs=='flo' : 
           if orbs=='scdm-g' : Y =  mf.ao.T 
           if orbs=='flo' : Y =  mf.ao.T / sqrt_rho[mf.piv]  
           G =   P @ Y
           O = Y.T @ P @ Y
           O12 = scipy.linalg.sqrtm(O).real
           Om12= scipy.linalg.pinv(O12).real 
           X = G @ Om12 
           P_loc = np.einsum('ia,ja->aji',X,X)
           SPloc = np.sum(P_loc, axis=0) 
           if 'testfd' not in dir(mf):  
               print('*** deviation sum_Pi from total P:', np.linalg.norm(SPloc-P) )
               assert np.linalg.norm(SPloc-P) <= 1E-8, 'Localized Densities'
           mf.orbs = X.T
           mf.ploc = P_loc
           mf.eigenv = np.linalg.eigvalsh(O)
           mf.cond   = np.linalg.cond(O)
           print('Eigenvalues of Overlap:')
           printL(mf.eigenv)
           print('Condition number: ', mf.cond)
         

        elif method=='elf': pass
        elif method=='lol': pass
        else: raise ValueError('Wrong orbital construction (use scdm-g,flo)')
    else:
        if orbs=='scdm-g' or orbs=='flo' : 
           if orbs=='scdm-g' : 
               Y_a =  mf.ao_a.T 
               Y_b =  mf.ao_b.T 
           if orbs=='flo' : 
               Y_a =  mf.ao_a.T / sqrt_rho_a[mf.piv_a]
               Y_b =  mf.ao_b.T / sqrt_rho_b[mf.piv_b]
           
         

           P_a = P[0]
           P_b = P[1]
           G_a =   P_a @ Y_a
           G_b =   P_b @ Y_b
           O_a = Y_a.T @ P_a @ Y_a
           O_b = Y_b.T @ P_b @ Y_b
           O12_a = scipy.linalg.sqrtm(O_a).real
           O12_b = scipy.linalg.sqrtm(O_b).real
           Om12_a= scipy.linalg.pinv(O12_a).real 
           Om12_b= scipy.linalg.pinv(O12_b).real 
           X_a = G_a @ Om12_a 
           X_b = G_b @ Om12_b 
           P_loc_a = np.einsum('ia,ja->aji',X_a,X_a)
           P_loc_b = np.einsum('ia,ja->aji',X_b,X_b)
           SPloc_a = np.sum(P_loc_a, axis=0) 
           SPloc_b = np.sum(P_loc_b, axis=0) 
           if 'testfd' not in dir(mf): assert np.linalg.norm(SPloc_a-P_a) <= 1E-7, 'Localized Densities alpha'
           if 'testfd' not in dir(mf): assert np.linalg.norm(SPloc_b-P_b) <= 1E-7, 'Localized Densities beta '
           mf.orbs_a = X_a.T
           mf.orbs_b = X_b.T
           mf.ploc_a = P_loc_a
           mf.ploc_b = P_loc_b

           mf.eigenv_a = np.linalg.eigvalsh(O_a)
           mf.eigenv_b = np.linalg.eigvalsh(O_b)
           mf.cond_a   = np.linalg.cond(O_a)
           mf.cond_b   = np.linalg.cond(O_b)
        elif method=='elf': pass
        elif method=='lol': pass
        else: raise ValueError('Wrong orbital construction (use scdm-g,flo)')
 


    if is_r:
        return coords[mf.piv]
    else:
        return coords[mf.piv_a], coords[mf.piv_b]





def get_veff_rsic(ks, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1,prt=True):
    '''Coulomb + XC functional

    .. note::
        This function will modify the input ks object.

    Args:
        ks : an instance of :class:`RKS`
            XC functional are controlled by ks.xc attribute.  Attribute
            ks.grids might be initialized.
        dm : ndarray or list of ndarrays
            A density matrix or a list of density matrices

    Kwargs:
        dm_last : ndarray or a list of ndarrays or 0
            The density matrix baseline.  If not 0, this function computes the
            increment of HF potential w.r.t. the reference HF potential matrix.
        vhf_last : ndarray or a list of ndarrays or 0
            The reference Vxc potential matrix.
        hermi : int
            Whether J, K matrix is hermitian

            | 0 : no hermitian or symmetric
            | 1 : hermitian
            | 2 : anti-hermitian

    Returns:
        matrix Veff = J + Vxc.  Veff can be a list matrices, if the input
        dm is a list of density matrices.
    '''
    if mol is None: mol = ks.mol
    if dm is None: dm = ks.make_rdm1()
    ks.initialize_grids(mol, dm)

    method = ks.method
    orbs = ks.mkorbs



    t0 = (logger.process_clock(), logger.perf_counter())

    ground_state = (isinstance(dm, np.ndarray) and dm.ndim == 2)

    ni = ks._numint
    if hermi == 2:  # because rho = 0
        n, exc, vxc = 0, 0, 0
    else:
        max_memory = ks.max_memory - lib.current_memory()[0]
        n, exc, vxc = ni.nr_rks(mol, ks.grids, ks.xc, dm, max_memory=max_memory)
        logger.debug(ks, 'nelec by numeric integration = %s', n)
        exc_save = exc
        esic = 0.0 
        xcsic = 0.0 
        gradlam = 0.0 
        n = mol.tot_electrons()

       
     
        if ks.sic == 'flo-sic':
             rks.sic_iter = 1
             calc_vsic = True
             nocc =  mol.nelec  
             S = mol.intor('int1e_ovlp')
             if not('piv' in dir(rks)):
               rks.sic_iter = 1
             else: 
               rks.sic_iter += 1
#
             if rks.sic_iter == 1: calc_vsic = True
  
             if 'calc_vsic' in dir(rks): calc_vsic = rks.calc_vsic
             scale_j  = 1.00e0
             scale_xc = 1.00e0
             if 'use_fod' not in dir(ks): ks.use_fod = False
             if calc_vsic:
                if ks.use_fod == False: 
                   newsic_g(mol,ks,dm,method=method,orbs=orbs)
                else:
                   fod = ks.fod
                   newsic_fod(mol,ks,dm,fod,orbs=orbs)
                   prt = False
                if prt: 
                   P_loc = ks.ploc 
                else:
                   P_loc = ks.ploc 
                   eig = ks.eigenv
                   cond = ks.cond
                  
                nsic, excsic1, v1sic = nr_uks(ni,mol, ks.grids, ks.xc, [P_loc,0.0e0*P_loc], max_memory=max_memory)
                excsic = excsic1*scale_xc
                v1sic *= scale_xc
                if prt: 
                   print('')
                   print('Evaluating self-XC for SIC orbitals')
                   printL(nsic[0])
                   printL(excsic)
                excsic = sum(excsic)


        if ks.nlc or ni.libxc.is_nlc(ks.xc):
            if ni.libxc.is_nlc(ks.xc):
                xc = ks.xc
            else:
                assert ni.libxc.is_nlc(ks.nlc)
                xc = ks.nlc
            n, enlc, vnlc = ni.nr_nlc_vxc(mol, ks.nlcgrids, xc, dm,
                                          max_memory=max_memory)
            exc += enlc
            vxc += vnlc
            logger.debug(ks, 'nelec with nlc grids = %s', n)
        t0 = logger.timer(ks, 'vxc', *t0)




    if not ni.libxc.is_hybrid_xc(ks.xc):
        vk = None
        if False:
            ddm = np.asarray(dm) - np.asarray(dm_last)
            vj = ks.get_j(mol, ddm, hermi=1)
            vj += vhf_last.vj
        else:
            vj = ks.get_j(mol, dm, hermi=1)
            if (ks.sic == 'flo-sic' and calc_vsic):
               v1j = scale_j*ks.get_j(mol, P_loc, hermi=1)
        vxc += vj
    else:
        omega, alpha, hyb = ni.rsh_and_hybrid_coeff(ks.xc, spin=mol.spin)
        if (ks._eri is None and ks.direct_scf and
            getattr(vhf_last, 'vk', None) is not None):
            ddm = np.asarray(dm) - np.asarray(dm_last)
            vj, vk = ks.get_jk(mol, ddm, hermi)
            vk *= hyb
            if omega != 0:  # For range separated Coulomb
                vklr = ks.get_k(mol, ddm, hermi, omega=omega)
                vklr *= (alpha - hyb)
                vk += vklr
            vj += vhf_last.vj
            vk += vhf_last.vk
        else:
            vj, vk = ks.get_jk(mol, dm, hermi=1)
            vk *= hyb
            if omega != 0:
                vklr = ks.get_k(mol, dm, hermi, omega=omega)
                vklr *= (alpha - hyb)
                vk += vklr
        vxc += vj - vk * .5

        if ground_state:
            exc -= np.einsum('ij,ji', dm, vk).real * .5 * .5

    if ground_state:
        ecoul = np.einsum('ij,ji', dm, vj).real * .5
    else:
        ecoul = None



    if (ks.sic == 'flo-sic' and calc_vsic):
           e1=[]
           for i in range(len(P_loc)):
              e1= np.append(e1, np.einsum('ij,ji', P_loc[i], v1j[i]).real  * .5  )
    
           ecoul1 = np.einsum('kij,kji', P_loc, v1j).real  * .5
           if prt: 
              print('Evaluating self-Hartree for SIC orbitals')
              printL(e1) 
              print('')
           scale_sic = ks.scale_sic # 0.2 # /(1.+1./rks.sic_iter**2)
           esic = (-ecoul1 -excsic)*scale_sic*2.0 # account for spin up and down




    if (ks.sic == 'flo-sic' and calc_vsic):
       vsic = get_vsic(ks,mol,v1j+v1sic[0],0.5*dm,spin=None,prt=prt)*scale_sic
       rks.esic = esic
       ks.esic = esic
       if ks.use_fod: ks.hsic = v1j+v1sic[0]

       veff = vxc + vsic # the plus is correct
    else:
       veff = vxc

    ks.exc = exc
    ks.ecoul =ecoul
    vhf = lib.tag_array(veff, ecoul=ecoul, exc=exc, vj=vj, vk=vk,esic=esic)
    if not prt:
      ks.eigenv = eig
      ks.cond = cond
    return vhf











def get_veff_usic(ks, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1, prt=True):
    '''Coulomb + XC +SIC functional for UKS.  See pyscf/dft/rks.py
    **** This is an in-house modified version to work with SIC ****
    :func:`get_veff` fore more details.
    [adapted from get_veff]
    '''
    if mol is None: mol = ks.mol
    if dm is None: dm = ks.make_rdm1()
    if not isinstance(dm, np.ndarray):
        dm = np.asarray(dm)
    if dm.ndim == 2:  # RHF DM
        dm = np.asarray((dm*.5,dm*.5))
    ks.initialize_grids(mol, dm)

    method = ks.method
    orbs = ks.mkorbs

    t0 = (logger.process_clock(), logger.perf_counter())

    ground_state = (dm.ndim == 3 and dm.shape[0] == 2)

    ni = ks._numint
    if hermi == 2:  # because rho = 0
        n, exc, vxc = (0,0), 0, 0
    else:
        max_memory = ks.max_memory - lib.current_memory()[0]
        n, exc, vxc = ni.nr_uks(mol, ks.grids, ks.xc, dm, max_memory=max_memory)
        logger.debug(ks, 'nelec by numeric integration = %s', n)
        exc_save = exc
        esic = 0.0 
        xcsic = 0.0 
        gradlam = 0.0 
        n = mol.tot_electrons()
      
        if ks.sic == 'flo-sic':
             rks.sic_iter = 1
             calc_vsic = True
             nocc_a =  mol.nelec[0]  
             nocc_b =  mol.nelec[1]
             S = mol.intor('int1e_ovlp')
             if not('piv_a' in dir(rks)):
               rks.sic_iter = 1
             else: 
               rks.sic_iter += 1
#
             if rks.sic_iter == 1: calc_vsic = True
  
             if 'calc_vsic' in dir(rks): calc_vsic = rks.calc_vsic
             scale_j  = 1.00e0
             scale_xc = 1.00e0
             if 'use_fod' not in dir(ks): ks.use_fod = False
             if calc_vsic:
                if ks.use_fod == False: 
                   newsic_g(mol,ks,dm,method=method,orbs=orbs)
                else:
                   fod_a = ks.fod_a.flatten()
                   fod_b = ks.fod_b.flatten()
                   fod = np.concatenate((fod_a,fod_b))
                   newsic_fod(mol,ks,dm,fod,orbs=orbs)
                   prt = False

                if prt: 
                   P_loc_a = ks.ploc_a 
                else:
                   P_loc_a = ks.ploc_a 
                   eig_a = ks.eigenv_a
                   cond_a = ks.cond_a
                if nocc_b == 1: 
                   P_loc_b =   np.asarray([dm[1]])
                   rks.piv_b  = [0]
                else:
                   if prt: 
                     P_loc_b = ks.ploc_b 
                   else:
                     P_loc_b = ks.ploc_b
                     eig_b = ks.eigenv_b
                     cond_b = ks.cond_b
                  
                nsic, excsic1, v1sic = nr_uks(ni,mol, ks.grids, ks.xc, [P_loc_a,0.0e0*P_loc_a], max_memory=max_memory)
                nsic_a = nsic[0]
                excsic_a = excsic1*scale_xc
                v1sic_a = v1sic[0]*scale_xc
                if prt: 
                   print('')
                   print('Evaluating self-XC for SIC alpha')
                   printL(nsic_a)
                   printL(excsic_a)
                excsic_a = sum(excsic_a)
                nsic, excsic1, v1sic = nr_uks(ni,mol, ks.grids, ks.xc, [P_loc_b,0.0e0*P_loc_b], max_memory=max_memory)
                nsic_b = nsic[0]
                excsic_b = excsic1*scale_xc
                v1sic_b = v1sic[0]*scale_xc
                if prt:
                   print('Evaluating self-XC for SIC beta')
                   printL(nsic_b)
                   printL(excsic_b)
                excsic_b = sum(excsic_b)



    

        if ks.nlc or ni.libxc.is_nlc(ks.xc):
            if ni.libxc.is_nlc(ks.xc):
                xc = ks.xc
            else:
                assert ni.libxc.is_nlc(ks.nlc)
                xc = ks.nlc
            n, enlc, vnlc = ni.nr_nlc_vxc(mol, ks.nlcgrids, xc, dm[0]+dm[1],
                                          max_memory=max_memory)
            exc += enlc
            vxc += vnlc
            logger.debug(ks, 'nelec with nlc grids = %s', n)
        t0 = logger.timer(ks, 'vxc', *t0)


    if not ni.libxc.is_hybrid_xc(ks.xc):
        vk = None
        if False:
            ddm = np.asarray(dm) - np.asarray(dm_last)
            vj = ks.get_j(mol, ddm[0]+ddm[1], hermi)
            vj += vhf_last.vj
        else:
            vj = ks.get_j(mol, dm[0]+dm[1], hermi)
            if (ks.sic == 'flo-sic' and calc_vsic):
               v1j_a = scale_j*ks.get_j(mol, P_loc_a, hermi)
               v1j_b = scale_j*ks.get_j(mol, P_loc_b, hermi)

        vxc += vj
    else:
        omega, alpha, hyb = ni.rsh_and_hybrid_coeff(ks.xc, spin=mol.spin)
        if (ks._eri is None and ks.direct_scf and
            getattr(vhf_last, 'vk', None) is not None):
            ddm = np.asarray(dm) - np.asarray(dm_last)
            vj, vk = ks.get_jk(mol, ddm, hermi)
            vk *= hyb
            if omega != 0:
                vklr = ks.get_k(mol, ddm, hermi, omega)
                vklr *= (alpha - hyb)
                vk += vklr
            vj = vj[0] + vj[1] + vhf_last.vj
            vk += vhf_last.vk
        else:
            vj, vk = ks.get_jk(mol, dm, hermi)
            vj = vj[0] + vj[1]
            vk *= hyb
            if omega != 0:
                vklr = ks.get_k(mol, dm, hermi, omega)
                vklr *= (alpha - hyb)
                vk += vklr
        vxc += vj - vk

        if ground_state:
            exc -=(np.einsum('ij,ji', dm[0], vk[0]).real +
                   np.einsum('ij,ji', dm[1], vk[1]).real) * .5
    if ground_state:
        ecoul = np.einsum('ij,ji', dm[0]+dm[1], vj).real * .5
    else:
        ecoul = None

    if (ks.sic == 'flo-sic' and calc_vsic):
# fix : this can be shortened to np.einsum('kij,kji->k', p_loc, v1j).real  * .5
           e1_a=[]
           e1_b=[]
           for i in range(len(P_loc_a)):
              e1_a= np.append(e1_a, np.einsum('ij,ji', P_loc_a[i], v1j_a[i]).real  * .5  )
           for i in range(len(P_loc_b)):
              e1_b= np.append(e1_b, np.einsum('ij,ji', P_loc_b[i], v1j_b[i]).real  * .5  )
    
           ecoul1_a = np.einsum('kij,kji', P_loc_a, v1j_a).real  * .5
           ecoul1_b = np.einsum('kij,kji', P_loc_b, v1j_b).real  * .5
           if prt: 
              print('Evaluating self-Hartree for SIC alpha')
              printL(e1_a) 
              print('Evaluating self-Hartree for SIC beta')
              printL(e1_b) 
              print('')
           scale_sic = ks.scale_sic # 0.2 # /(1.+1./rks.sic_iter**2)
           esic = (-ecoul1_a -ecoul1_b -excsic_a -excsic_b)*scale_sic




    if (ks.sic == 'flo-sic' and calc_vsic):
       vsic_a = get_vsic(ks,mol,v1j_a+v1sic_a,dm[0],spin='a',prt=prt)*scale_sic
       vsic_b = get_vsic(ks,mol,v1j_b+v1sic_b,dm[1],spin='b',prt=prt)*scale_sic
       veff = vxc + np.asarray((vsic_a,vsic_b))  # the plus is correct
       rks.esic = esic
       ks.esic = esic
       if ks.use_fod:
          ks.hsic_a = v1j_a+v1sic_a
          ks.hsic_b = v1j_b+v1sic_b
    else:
       veff = vxc


    ks.exc = exc
    ks.ecoul =ecoul
    vhf = lib.tag_array(veff, ecoul=ecoul, exc=exc, vj=vj, vk=vk,esic=esic)
    if not prt:
      ks.eigenv_a = eig_a
      ks.eigenv_b = eig_b
      ks.cond_a = cond_a
      ks.cond_b = cond_b
    return vhf



def make_square(P):
   if P.ndim == 1:  
     N = int(np.sqrt(len(P)))
     R =  np.reshape(P, (N,N) )
   else:
     R = P 
   return R 

def make_linear(P):
   if P.ndim == 2:  
      N = len(P)
      R = np.reshape(P, N*N ) 
   else:
      R = P 
   return R



def energy_sic(dm1, ks,s,dm2):
    '''Electronic SIC part of RKS energy.
    Returns:
         SIC electronic 
    '''
    dm1 = make_square(dm1)
    if s!=3: dm2 = make_square(dm2)
    if s==0: dm =[dm1,dm2]
    if s==1: dm =[dm2,dm1]
    if s==3: dm = np.array(dm1)
    if s!=3: 
        v = get_veff_usic(ks, ks.mol, dm, prt=True )
    else:
        v = get_veff_rsic(ks, ks.mol, dm, prt=True )
    esic = v.esic.real
    exc = v.exc
    ecoul = v.ecoul
    eel = esic + exc + ecoul
    if s!=3: return eel, ks.piv_a, ks.piv_b
    else: return eel, ks.piv







def d_energy_sic(dm1, ks,s,dm2):
    '''  
    Wrapper to  get_veff_usic to get only the SIC KS matrix
    '''
    dm1 = make_square(dm1)
    if s!=3: dm2 = make_square(dm2)
    if s==0: dm =np.asarray((dm1,dm2))
    if s==1: dm =np.asarry((dm2,dm1))
    if s==3: dm = np.array(dm1)
    if s!=3: 
        v = get_veff_usic(ks, ks.mol, dm, prt=False )[s]
    else:
        v = get_veff_rsic(ks, ks.mol, dm, prt=False )
    return v #+vsic  # ks.vsic[s]




def energy_sic_piv(dm, ks,piv):
    '''Electronic SIC part of RKS energy.
    Returns:
         SIC electronic energy for a set of pivoting vectors
    '''
    ks.reuse_piv = True
    rks.piv_a  = piv[0]
    rks.piv_b  = piv[1]


    v = get_veff_usic(ks, ks.mol, dm, prt=False )
    esic = v.esic.real
    ecoul = ks.ecoul.real
    exc = ks.exc.real
    eig_a = min(ks.eigenv_a)
    eig_b = min(ks.eigenv_b)
    cond_a = abs(ks.cond_a)
    cond_b = abs(ks.cond_b)
    
    return   esic, min(eig_a,eig_b), max(cond_a,cond_b)   #exc+ecoul+esic




def energy_sic_fod(FOD,  ks,mol):
    '''Electronic SIC part of RKS energy.
    Returns:
         SIC electronic energy for a set of FODs
    '''
    dm = ks.make_rdm1() 
    fod = FOD.reshape((-1,3)).copy()
    if dm.ndim == 2: is_r = True
    else: is_r = False

    newsic_fod(mol,ks,dm,fod,orbs=ks.mkorbs)
    max_memory = ks.max_memory - lib.current_memory()[0]

    ni = ks._numint
    if is_r: 
       p_loc = ks.ploc 
       nsic, excsic1, v1sic = nr_uks(ni,mol, ks.grids, ks.xc, [p_loc,0.e0*p_loc], max_memory=max_memory)
       v1j = ks.get_j(mol, p_loc, hermi=1)
       e1j = np.einsum('kij,kji->k', p_loc, v1j).real  * .5
       esic = 2.e0*(-sum(e1j) - sum(excsic1)) 
    else:
       p_loca = ks.ploc_a
       p_locb = ks.ploc_b
       nsica, excsic1a, v1sica = nr_uks(ni,mol, ks.grids, ks.xc, [p_loca,0.e0*p_loca], max_memory=max_memory)
       nsicb, excsic1b, v1sicb = nr_uks(ni,mol, ks.grids, ks.xc, [p_locb,0.e0*p_locb], max_memory=max_memory)
       v1ja = ks.get_j(mol, p_loca, hermi=1)
       v1jb = ks.get_j(mol, p_locb, hermi=1)
       e1ja = np.einsum('kij,kji->k', p_loca, v1ja).real  * .5
       e1jb = np.einsum('kij,kji->k', p_locb, v1jb).real  * .5
       esic = -sum(e1ja) - sum(excsic1a) -sum(e1jb) - sum(excsic1b) 

    return   esic 


def totener_fod(FOD,  ks,mol):

    dm = ks.make_rdm1()
    if dm.ndim == 2: is_r = True
    else: is_r = False

    max_memory = ks.max_memory - lib.current_memory()[0]
    
    ni = ks._numint
    fod = FOD.reshape((-1,3)).copy()   
    esic = energy_sic_fod(fod,  ks,mol)

    n, exc, v1 = ni.nr_uks(mol, ks.grids, ks.xc, dm, max_memory=max_memory)
    j = ks.get_j(mol, dm, hermi=1)
    ej = np.einsum('ij,ji->', dm, j).real  * .5
    h1e = ks.get_hcore() 
    ecore = np.einsum('ij,ji->', h1e, dm).real
    enuc = ks.energy_nuc()
    E = ej + exc +ecore   + esic + enuc
#    print('Energy = ', E)
    return E



def scf_ener_fod(FOD, ks,mol):
    sys.stdout.flush()
    dm = ks.make_rdm1()
    ks.verbose = 0 
    if dm.ndim == 2: is_r = True
    else: is_r = False
    ks.use_fod = True
    lib.logger.new_logger(None, 0)
#    ks.kernel here. But we need to make sure that the scf uses the FODs in FOD, not the QR decomposition.
#    we can replace newsic_g with newsic_fod (with a proper logical switch)    
    

    fod = FOD.reshape((-1,3)).copy()
    if  is_r: 
         old_fod = ks.fod
         ks.fod = fod
    else:
          Na, Nb = mol.nelec
          fod_a = fod[:Na]
          fod_b = fod[Na:]
          old_fod = np.vstack((ks.fod_a,ks.fod_b)).reshape((-1,3))
          ks.fod_a = fod_a
          ks.fod_b = fod_b
          assert Na+Nb == len(fod), 'Len of FODs is wrong'
    r = ks.kernel(dm0=dm)
    ener_new = r[1]
    conver = r[0]
    
    gradients = get_grad_fod(fod,ks,mol)
    displ = np.linalg.norm(old_fod-fod)
    print(f'Energy= {ks.e_tot:16.10f} RMS FOD grad= {np.linalg.norm(gradients):10.4e} displ= {displ:6.2e} scf cycles= {ks.cycle+1:3d}' )
    if not conver: print('>>>>>>> SCF did not converge! <<<<<<<<<')
    sys.stdout.flush()
    return ks.e_tot  , gradients






def energy_elec_sic(ks, dm=None, h1e=None, vhf=None):
    '''
    **** This is an in-house modified version to work with sic ****
    energy_elec adapted for the UKS case with SIC
    '''
    if(ks.sic=='flo-sic'): 
       if dm is None: dm = ks.make_rdm1()
       if np.array(dm).ndim == 2: is_r = True
       else: is_r = False
       if not is_r: dm = dm[0] + dm[1]

       if h1e is None: h1e = ks.get_hcore()
       if vhf is None or getattr(vhf, 'ecoul', None) is None:
           vhf = get_veff_usic(ks, ks.mol, dm)
       e1 = np.einsum('ij,ji->', h1e, dm).real
       ecoul = ks.ecoul.real
       exc = ks.exc.real
       esic = vhf.esic.real
       e2 = ecoul + exc
       nuc = ks.energy_nuc()
       ks.scf_summary['e1'] = e1
       ks.scf_summary['e2'] = e2
       ks.scf_summary['coul'] = ecoul
       ks.scf_summary['exc'] = exc
       ks.scf_summary['esic'] = esic
       ks.scf_summary['e_tot'] = e1+e2+esic+nuc
       ks.scf_summary['e_dft'] = e1+e2+nuc
       vhf.e_tot = e1+e2+esic+nuc
       vhf.e_dft = e1+e2
       verbose=4
       log = logger.new_logger(ks, verbose)
       summary = ks.scf_summary
       def write(fmt, key):
           if key in summary: log.info(fmt, summary[key])
       if 'use_fod' not in dir(ks): ks.use_fod = False
       if not  ks.use_fod:
           write('Total Energy =                    %24.15f', 'e_tot')
           write('Nuclear Repulsion Energy =        %24.15f', 'nuc')
           write('One-electron Energy =             %24.15f', 'e1')
           write('Two-electron Energy =             %24.15f', 'e2')
           write('Two-electron Coulomb Energy =     %24.15f', 'coul')
           write('DFT Exchange-Correlation Energy = %24.15f', 'exc')
           write('Total DFT Energy (no SIC)       = %24.15f', 'e_dft')
           write('SIC  Energy                     = %24.15f', 'esic')
       return  e1+e2+esic, e2   
    else:  # this is not working....
      if dm is None: dm = ks.make_rdm1()
      if h1e is None: h1e = ks.get_hcore()
      if vhf is None or getattr(vhf, 'ecoul', None) is None:
          vhf = ks.get_veff(ks.mol, dm)
      if not (isinstance(dm, np.ndarray) and dm.ndim == 2): 
          dm = dm[0] + dm[1]
      return rks.energy_elec(ks, dm, h1e, vhf)



def kernel_sic(mf, conv_tol=1e-10, conv_tol_grad=None,
           dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):
    ''' 
    **** This is an in-house modified version to work with sic ****
    kernel: the SCF driver.

    Args:
        mf : an instance of SCF class
            mf object holds all parameters to control SCF.  One can modify its
            member functions to change the behavior of SCF.  The member
            functions which are called in kernel are

            | mf.get_init_guess
            | mf.get_hcore
            | mf.get_ovlp
            | mf.get_veff
            | mf.get_fock
            | mf.get_grad
            | mf.eig
            | mf.get_occ
            | mf.make_rdm1
            | mf.energy_tot
            | mf.dump_chk

    Kwargs:
        conv_tol : float
            converge threshold.
        conv_tol_grad : float
            gradients converge threshold.
        dump_chk : bool
            Whether to save SCF intermediate results in the checkpoint file
        dm0 : ndarray
            Initial guess density matrix.  If not given (the default), the kernel
            takes the density matrix generated by ``mf.get_init_guess``.
        callback : function(envs_dict) => None
            callback function takes one dict as the argument which is
            generated by the builtin function :func:`locals`, so that the
            callback function can access all local variables in the current
            environment.

    Returns:
        A list :   scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

        scf_conv : bool
            True means SCF converged
        e_tot : float
            Hartree-Fock energy of last iteration
        mo_energy : 1D float array
            Orbital energies.  Depending the eig function provided by mf
            object, the orbital energies may NOT be sorted.
        mo_coeff : 2D array
            Orbital coefficients.
        mo_occ : 1D array
            Orbital occupancies.  The occupancies may NOT be sorted from large
            to small.

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1', basis='cc-pvdz')
    >>> conv, e, mo_e, mo, mo_occ = scf.hf.kernel(scf.hf.SCF(mol), dm0=np.eye(mol.nao_nr()))
    >>> print('conv = %s, E(HF) = %.12f' % (conv, e))
    conv = True, E(HF) = -1.081170784378
    '''
    if 'init_dm' in kwargs:
        raise RuntimeError('''
You see this error message because of the API updates in pyscf v0.11.
Keyword argument "init_dm" is replaced by "dm0"''')
    cput0 = (logger.process_clock(), logger.perf_counter())
    if conv_tol_grad is None:
        conv_tol_grad = np.sqrt(conv_tol)
        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)

    mol = mf.mol
    if dm0 is None:
        dm = mf.get_init_guess(mol, mf.init_guess)
    else:
        dm = dm0

    s1e = mf.get_ovlp(mol)
    cond = lib.cond(s1e)
    logger.debug(mf, 'cond(S) = %s', cond)
    if np.max(cond)*1e-17 > conv_tol:
        logger.warn(mf, 'Singularity detected in overlap matrix (condition number = %4.3g). '
                    'SCF may be inaccurate and hard to converge.', np.max(cond))

    mf.S12 = scipy.linalg.sqrtm(s1e).real  
    mf.Sm12 = inv(mf.S12)  
    mf.e_old = 0.000
    mf.e_new = 9.999  


    h1e = mf.get_hcore(mol)
    vhf = mf.get_veff(mol, dm)
    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', e_tot)

    scf_conv = False
    mo_energy = mo_coeff = mo_occ = None



    # Skip SCF iterations. Compute only the total energy of the initial density
    if mf.max_cycle <= 0:
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        mf.mo_coeff = mo_coeff
        mf.mo_occ = mo_occ 
        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

    if isinstance(mf.diis, lib.diis.DIIS):
        mf_diis = mf.diis
    elif mf.diis:
        assert issubclass(mf.DIIS, lib.diis.DIIS)
        mf_diis = mf.DIIS(mf, mf.diis_file)
        mf_diis.space = mf.diis_space
        mf_diis.rollback = mf.diis_space_rollback

        # We get the used orthonormalized AO basis from any old eigendecomposition.
        # Since the ingredients for the Fock matrix has already been built, we can
        # just go ahead and use it to determine the orthonormal basis vectors.
        fock = mf.get_fock(h1e, s1e, vhf, dm)
        _, mf_diis.Corth = mf.eig(fock, s1e)
    else:
        mf_diis = None

    if dump_chk and mf.chkfile:
        # Explicit overwrite the mol object in chkfile
        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"
        chkfile.save_mol(mol, mf.chkfile)

    TIGHT_GRAD_CONV_TOL = getattr(__config__, 'scf_hf_kernel_tight_grad_conv_tol', True)

    # A preprocessing hook before the SCF iteration
    mf.pre_kernel(locals())

    cput1 = logger.timer(mf, 'initialize scf', *cput0)
    for cycle in range(mf.max_cycle):
        dm_last = dm
        last_hf_e = e_tot
        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm = mf.make_rdm1(mo_coeff, mo_occ)
        mf.mo_coeff = mo_coeff
        mf.mo_occ = mo_occ
        vhf_last=vhf
        vhf = mf.get_veff(mol=mol, dm=dm, dm_last=dm_last, vhf_last=vhf)
        d_fock_0 = np.linalg.norm(vhf[0] - vhf_last[0] ) 
        d_fock_1 = np.linalg.norm(vhf[1] - vhf_last[1] ) 
        e_tot = mf.energy_tot(dm, h1e, vhf)

        # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock
        # instead of the statement "fock = h1e + vhf" because Fock matrix may
        # be modified in some methods.
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        if fock.ndim==2:
           diis_e = np.linalg.norm(fock@dm@s1e - s1e@dm@fock )
           CErr = np.sqrt(diis_e**2)
        else:
           diis_e_0 = np.linalg.norm(fock[0]@dm[0]@s1e - s1e@dm[0]@fock[0] )
           diis_e_1 = np.linalg.norm(fock[1]@dm[1]@s1e - s1e@dm[1]@fock[1] )
           CErr = np.sqrt(diis_e_0**2 + diis_e_1**2)
        if 'use_fod' not in dir(mf): mf.use_fod = False
        if not mf.use_fod: print(f'Commutator Error: {CErr:10.4e} ')
        mf.cycle = cycle

        norm_gorb = np.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))

        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / np.sqrt(norm_gorb.size)
        norm_ddm = np.linalg.norm(dm-dm_last)
        if mf.use_fod: logger.new_logger(None, 0)
        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)

        mf.e_old = last_hf_e
        mf.e_new = e_tot  
        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:
            scf_conv = True

        if dump_chk:
            mf.dump_chk(locals())

        if callable(callback):
            callback(locals())

        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)

        if scf_conv:
            break







    if scf_conv and conv_check and not mf.use_fod:
        # An extra diagonalization, to remove level shift
        #fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm
        mf.mo_coeff = mo_coeff
        mf.mo_occ = mo_occ
        vhf = mf.get_veff(mol, dm, dm_last, vhf)
        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot

        fock = mf.get_fock(h1e, s1e, vhf, dm)
        norm_gorb = np.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / np.sqrt(norm_gorb.size)
        norm_ddm = np.linalg.norm(dm-dm_last)

        conv_tol = conv_tol * 10
        conv_tol_grad = conv_tol_grad * 3
        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:
            scf_conv = True
        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)
        if dump_chk:
            mf.dump_chk(locals())

    logger.timer(mf, 'scf_cycle', *cput0)



 
    nocca =  mol.nelec[0]  
    noccb =  mol.nelec[1]  



    mf.post_kernel(locals())
    mf.mo_coeff = mo_coeff
    mf.mo_occ = mo_occ
    mf.scf_conv =scf_conv
    mf.e_tot = e_tot
    mf.mo_energy = mo_energy





    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ







   



def get_vsic(ks,mol,vsic,P,spin=None,prt=True):
    ov12 = ks.S12     
    ovm12 = ks.Sm12   


    ht = torch.tensor( vsic  , dtype=torch.float64, requires_grad=False)
    Pt = torch.tensor( P  , dtype=torch.float64, requires_grad=True)
    S12 = torch.tensor( ov12  , dtype=torch.float64, requires_grad=False)
    Sm12 = torch.tensor( ovm12  , dtype=torch.float64, requires_grad=False)
    

    

    if spin=='a' : 
          YTt = torch.tensor(ks.ao_a,dtype=torch.float64, requires_grad=False)
          Yt = torch.tensor(ks.ao_a.T,dtype=torch.float64, requires_grad=False)
    if spin=='b' : 
          YTt = torch.tensor(ks.ao_b,dtype=torch.float64, requires_grad=False)
          Yt = torch.tensor(ks.ao_b.T,dtype=torch.float64, requires_grad=False)
    if spin==None: 
          YTt = torch.tensor(ks.ao  ,dtype=torch.float64, requires_grad=False)
          Yt = torch.tensor(ks.ao.T  ,dtype=torch.float64, requires_grad=False)

    if ks.mkorbs=='scdm-g' or ks.mkorbs=='flo' :
        if ks.mkorbs=='scdm-g' : 
             pass
        if ks.mkorbs=='flo' : 
             tmp = torch.mm(YTt,Pt)
             rho = torch.mm(tmp,Yt)
             sqrtrho = torch.sqrt(torch.diagonal(rho))
             Yt = torch.div(Yt,sqrtrho)
             YTt= torch.transpose(Yt,0,1)
        Gt =  torch.mm( Pt, Yt)
        O1 = torch.mm(YTt, Pt) 
        Ot = torch.mm(O1, Yt)
        O12t = sqrtm(Ot).real
        Om12t = torch.linalg.inv(O12t)
        Xt = torch.mm(Gt,Om12t)

        P_loc = torch.einsum('ia,ja->aji',Xt,Xt)
        SPloc = torch.sum(P_loc, axis=0)
        if 'testfd' not in dir(ks): assert torch.norm(SPloc-Pt) <= 1E-7, 'Localized Densities'

        if spin=='a' : pivs ='alpha'
        if spin=='b' : pivs =' beta'
        if spin==None : pivs='  RKS'

        ESICt =   torch.sum( ht * P_loc ) 
        ESICt.backward()
        dEdP = Pt.grad

        dedp = dEdP.detach().numpy()
        R =  -0.5*(dedp + dedp.T.conj()).real




    return R






def get_grad_fod(FOD,ks,mol):

    ov12 = ks.S12 
    ovm12 = ks.Sm12 
    S12 = torch.tensor( ov12  , dtype=torch.float64, requires_grad=False)
    Sm12 = torch.tensor( ovm12  , dtype=torch.float64, requires_grad=False)

#
#
    P = ks.make_rdm1()
    if P.ndim == 2:
      is_r = True
      Pt = torch.tensor( P  , dtype=torch.float64, requires_grad=False)
      
    else:
      is_r = False
      Pta = torch.tensor( P[0]  , dtype=torch.float64, requires_grad=False)
      Ptb = torch.tensor( P[1]  , dtype=torch.float64, requires_grad=False)
      
      
  

    fod0 = FOD.reshape((-1,3)).copy()
    if is_r:     
      ao0  = mol.eval_gto('GTOval',fod0) 
      gao0 = mol.eval_gto('GTOval_ip', fod0)  
      fod0 = fod0.flatten()
      ao = torch.tensor(ao0,dtype=torch.float64, requires_grad=True)
      YTt = ao
      Yt = torch.transpose(YTt,0,1)
    else:

      Na, Nb = mol.nelec
      fod0a = fod0[:Na]
      fod0b = fod0[Na:]
      assert Na+Nb == len(fod0), 'Len of FODs is wrong'
      ao0a  = mol.eval_gto('GTOval',fod0a) 
      ao0b  = mol.eval_gto('GTOval',fod0b) 
      gao0a = mol.eval_gto('GTOval_ip', fod0a)  
      gao0b = mol.eval_gto('GTOval_ip', fod0b)  
      fod0a = fod0a.flatten()
      fod0b = fod0b.flatten()
      aoa = torch.tensor(ao0a,dtype=torch.float64, requires_grad=True)
      aob = torch.tensor(ao0b,dtype=torch.float64, requires_grad=True)
      YTta = aoa
      YTtb = aob
      Yta = torch.transpose(YTta,0,1)
      Ytb = torch.transpose(YTtb,0,1)
 


    if is_r: 
      if ks.mkorbs=='scdm-g' or ks.mkorbs=='flo' :
          if ks.mkorbs=='scdm-g' : 
               pass
          if ks.mkorbs=='flo' : 
               tmp = torch.mm(YTt,Pt)
               rho = torch.mm(tmp,Yt)
               sqrtrho = torch.sqrt(torch.diagonal(rho))
               Yt = torch.div(Yt,sqrtrho)
               YTt= torch.transpose(Yt,0,1)
          Gt =  torch.mm( Pt, Yt)
          O1 = torch.mm(YTt, Pt) 
          Ot = torch.mm(O1, Yt)
          O12t = sqrtm(Ot).real
          Om12t = torch.linalg.inv(O12t)
          Xt = torch.mm(Gt,Om12t)

          P_loc = torch.einsum('ia,ja->aji',Xt,Xt)
          SPloc = torch.sum(P_loc, axis=0)
          if 'testfd' not in dir(ks): assert torch.norm(SPloc-Pt) <= 1E-7, 'Localized Densities'

          max_memory = ks.max_memory - lib.current_memory()[0]
          p_loc = 0.5*P_loc.detach().numpy()
          ni = ks._numint
          nsic, excsic1, v1sic = nr_uks(ni,mol, ks.grids, ks.xc, [p_loc,0.0e0*p_loc], max_memory=max_memory)
          v1j = ks.get_j(mol, p_loc, hermi=1)
          ht = torch.tensor( -v1j - v1sic[0],dtype=torch.float64, requires_grad=False)
          e1j = np.einsum('kij,kji->k', p_loc, v1j).real  * .5
    else:
      if ks.mkorbs=='scdm-g' or ks.mkorbs=='flo' :
          if ks.mkorbs=='scdm-g' : 
               pass
          if ks.mkorbs=='flo' : 
               tmpa = torch.mm(YTta,Pta)
               tmpb = torch.mm(YTtb,Ptb)
               rhoa = torch.mm(tmpa,Yta)
               rhob = torch.mm(tmpb,Ytb)
               sqrtrhoa = torch.sqrt(torch.diagonal(rhoa))
               sqrtrhob = torch.sqrt(torch.diagonal(rhob))
               Yta = torch.div(Yta,sqrtrhoa)
               Ytb = torch.div(Ytb,sqrtrhob)
               YTta= torch.transpose(Yta,0,1)
               YTtb= torch.transpose(Ytb,0,1)
          Gta =  torch.mm( Pta, Yta)
          Gtb =  torch.mm( Ptb, Ytb)
          O1a = torch.mm(YTta, Pta) 
          O1b = torch.mm(YTtb, Ptb) 
          Ota = torch.mm(O1a, Yta)
          Otb = torch.mm(O1b, Ytb)
          O12ta = sqrtm(Ota).real
          O12tb = sqrtm(Otb).real
          Om12ta = torch.linalg.inv(O12ta)
          Om12tb = torch.linalg.inv(O12tb)
          Xta = torch.mm(Gta,Om12ta)
          Xtb = torch.mm(Gtb,Om12tb)

          P_loca = torch.einsum('ia,ja->aji',Xta,Xta)
          P_locb = torch.einsum('ia,ja->aji',Xtb,Xtb)
          SPloca = torch.sum(P_loca, axis=0)
          SPlocb = torch.sum(P_locb, axis=0)
          if 'testfd' not in dir(ks): 
              if not is_r: assert torch.norm(SPloca-Pta) <= 1E-7, 'Localized Densities alpha'
              if not is_r: assert torch.norm(SPlocb-Ptb) <= 1E-7, 'Localized Densities beta'
              if     is_r: assert torch.norm(SPloc-Pt) <= 1E-7, 'Localized Densities closed-shell'

          max_memory = ks.max_memory - lib.current_memory()[0]





    if is_r: 
              if 'testfd' in  dir(ks):
                 p_loc = 0.5*P_loc.detach().numpy()
                 ni = ks._numint
                 nsic, excsic1, v1sic = nr_uks(ni,mol, ks.grids, ks.xc, [p_loc,0.e0*p_loc], max_memory=max_memory)
                 v1j = ks.get_j(mol, p_loc, hermi=1)
                 ht = torch.tensor( -v1j - v1sic[0],dtype=torch.float64, requires_grad=False)
              else:
                 ht = torch.tensor( -ks.hsic,dtype=torch.float64, requires_grad=False)
              ESICt =  torch.sum( ht * P_loc ) 
              ESICt.backward()
              dedao = ao.grad.detach().numpy()
              R0 =   np.einsum('ia,jka->ijk',dedao,gao0)
              R = np.diagonal(R0,axis1=0, axis2=2, ).T.flatten()

              return R
    else: 
              if 'testfd' in  dir(ks):
                 p_loca = P_loca.detach().numpy()
                 p_locb = P_locb.detach().numpy()
                 ni = ks._numint
                 nsica, excsic1a, v1sica = nr_uks(ni,mol, ks.grids, ks.xc, [p_loca,0.0e0*p_loca], max_memory=max_memory)
                 nsicb, excsic1b, v1sicb = nr_uks(ni,mol, ks.grids, ks.xc, [p_locb,0.0e0*p_locb], max_memory=max_memory)
                 v1ja = ks.get_j(mol, p_loca, hermi=1)
                 v1jb = ks.get_j(mol, p_locb, hermi=1)
                 hta = torch.tensor( -v1ja - v1sica[0],dtype=torch.float64, requires_grad=False)
                 htb = torch.tensor( -v1jb - v1sicb[0],dtype=torch.float64, requires_grad=False)
              else:
                 hta = torch.tensor( -ks.hsic_a,dtype=torch.float64, requires_grad=False)
                 htb = torch.tensor( -ks.hsic_b,dtype=torch.float64, requires_grad=False)
              ESICta =  torch.sum( hta * P_loca ) 
              ESICta.backward()
              dedaoa = aoa.grad.detach().numpy()
              R0a =   np.einsum('ia,jka->ijk',dedaoa,gao0a)
              Ra = np.diagonal(R0a,axis1=0, axis2=2, ).T.flatten()
              ESICtb =  torch.sum( htb * P_locb ) 
              ESICtb.backward()
              dedaob = aob.grad.detach().numpy()
              R0b =   np.einsum('ia,jka->ijk',dedaob,gao0b)
              Rb = np.diagonal(R0b,axis1=0, axis2=2, ).T.flatten()

              return np.concatenate((Ra, Rb))







class RSIC(rks.KohnShamDFT, hf.RHF):
    '''
    Restricted Kohn-Sham with SIC
    See pyscf/dft/rks.py RKS class for document of the attributes'''
    __doc__ = '''Restricted Kohn-Sham\n''' + hf.SCF.__doc__ + rks.KohnShamDFT.__doc__

    def __init__(self, mol, xc='LDA,VWN'):
        self.sic=''
        hf.RHF.__init__(self, mol)
        rks.KohnShamDFT.__init__(self, xc)

    def dump_flags(self, verbose=None):
        hf.RHF.dump_flags(self, verbose)
        return rks.KohnShamDFT.dump_flags(self, verbose)
        
    get_veff = get_veff_rsic
    get_vsap = rks.get_vsap
    energy_elec = energy_elec_sic
    kernel = kernel_sic

    init_guess_by_vsap = rks.init_guess_by_vsap
        
    def nuc_grad_method(self):
        from pyscf.grad import rks as rks_grad
        return rks_grad.Gradients(self)
    
    def to_hf(self):
        '''Convert to RHF object.'''
        return self._transfer_attrs_(self.mol.RHF())

    def to_gpu(self):
        from gpu4pyscf.dft.rks import RKS
        obj = lib.to_gpu(hf.SCF.reset(self.view(RKS)))
        # Attributes only defined in gpu4pyscf.RKS
        obj.screen_tol = 1e-14
        return obj







class USIC(rks.KohnShamDFT, uhf.UHF):
    '''
    Unrestricted Kohn-Sham with SIC
    See pyscf/dft/rks.py RKS class for document of the attributes'''
    def __init__(self, mol, xc='LDA,VWN'):
        self.sic=''
        uhf.UHF.__init__(self, mol)
        rks.KohnShamDFT.__init__(self, xc)

    def dump_flags(self, verbose=None):
        uhf.UHF.dump_flags(self, verbose)
        rks.KohnShamDFT.dump_flags(self, verbose)
        return self

    def initialize_grids(self, mol=None, dm=None):
        ground_state = (isinstance(dm, np.ndarray)
                        and dm.ndim == 3 and dm.shape[0] == 2)
        if ground_state:
            super().initialize_grids(mol, dm[0]+dm[1])
        else:
            super().initialize_grids(mol)
        return self
    get_veff = get_veff_usic
    get_vsap = uks.get_vsap
    energy_elec = energy_elec_sic
    kernel = kernel_sic
       
    init_guess_by_vsap = rks.init_guess_by_vsap

    def nuc_grad_method(self):
        from pyscf.grad import uks
        return uks.Gradients(self)

    def to_hf(self):
        '''Convert to UHF object.'''
        return self._transfer_attrs_(self.mol.UHF())



import sys


def printAt(s,a):
    for i,row in enumerate(a):
        print(f"{s[i]:s} ", end="")
        for col in row:
            print(f" {col:9.6f}", end=" ")
        print("")


def print_xyz(mol, FODs,fname):
    '''
    '''
    sys.stdout = open( fname+'.xyz'  , 'w')
    atom_coords = mol.atom_coords() / 1.8897259886  # convert Bohr to A

    # figure out if FODs has alpha and beta
    if FODs.__class__==tuple:
       FODs_a = FODs[0].reshape((-1,3))
       FODs_b = FODs[1].reshape((-1,3))
       is_r  = False
    else:
       is_r  = True
       FODs = FODs.reshape((-1,3))

    symbols =[]
    for i in range(len(atom_coords)):
        symbols.append(mol.atom_symbol(i))


    if len(symbols) == 1:   # if there is only one atom don't add it to the xyz file for visualization
        atom = True
    else:
        atom = False


    if is_r:
        sFOD=[]
        for i in range(len(FODs)):
            sFOD.append('X')
        if not atom: print(len(atom_coords) + len(FODs))
        if     atom: print( len(FODs))
    else:
        sFOD_a=[]
        for i in range(len(FODs_a)):
            sFOD_a.append('X')
        sFOD_b=[]
        for i in range(len(FODs_b)):
            sFOD_b.append('Z')
        if not atom: print(len(atom_coords) + len(FODs_a) + len(FODs_b))
        if     atom: print( len(FODs_a) + len(FODs_b))

    print("")
    if not atom: printAt(symbols,atom_coords)
    if is_r:
        printAt(sFOD,FODs/1.8897259886)   # Bohr to A
    else:
        printAt(sFOD_a,FODs_a/1.8897259886)   # Bohr to A
        printAt(sFOD_b,FODs_b/1.8897259886)   # Bohr to A

    sys.stdout.close()
    sys.stdout = sys.__stdout__
    print('Wrote '+ fname+'.xyz file' )


# Cubes! *********************************************************************8


def get_orb_cubes(mf,mol,strng):

    from pyscf.tools import cubegen

    Type = type(mf).__name__
    print('Generating Orbital Cubes for ',strng, ' type ',Type )
    functional = mf.xc
    basis = mol.basis
    molecule = mol.name
    if Type=='DFRSIC':
       FOD = mf.fod
#       fod = FOD.copy()
#       fod=fod.flatten()
       for i,C in enumerate(mf.orbs):
          cubegen.orbital(mol,  molecule+'.'+functional+'.'+basis+'.'+strng+f'.alpha_orb_{i+1}.cube', C,nx=80, ny=80, nz=80)
       print_xyz(mol, FOD , molecule+'.'+functional+'.'+basis+'.'+strng   )
    else:
       FOD_a = mf.fod_a
#       fod_a = FOD_a.copy()
#       fod_a = fod_a.flatten()
       FOD_b = mf.fod_b
#       fod_b = FOD_b.copy()
#       fod_b = fod_b.flatten()

       

       for i,C in enumerate(mf.orbs_a):
          cubegen.orbital(mol,  molecule+'.'+functional+'.'+basis+'.'+strng+f'.alpha_orb_{i+1}.cube', C,nx=80, ny=80, nz=80)
       for i,C in enumerate(mf.orbs_b):
          cubegen.orbital(mol,  molecule+'.'+functional+'.'+basis+'.'+strng+f'.beta_orb_{i+1}.cube', C,nx=80, ny=80, nz=80)
       print_xyz(mol, (FOD_a,FOD_b) , molecule+'.'+functional+'.'+basis+'.'+strng   )





